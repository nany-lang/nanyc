#include <yuni/yuni.h>
#include "scope.h"
#include "details/utils/check-for-valid-identifier-name.h"
#include "details/ir/emit.h"

using namespace Yuni;


namespace ny {
namespace ir {
namespace Producer {


namespace {


bool isShortcircuit(AST::Node& node, AST::Node* parent) {
	return parent != nullptr and parent->rule == AST::rgIdentifier
		and node.children.size() == 2
		and (parent->text == "^and" or parent->text == "^or");
}


bool emitFunCallNoParameter(Scope& scope, uint32_t functor, uint32_t& localvar) {
	auto& irout = scope.ircode();
	auto callret = ir::emit::alloc(irout, scope.nextvar());
	localvar = callret; // the new expression value
	// no pushed parameter - direct call - no need for scopes or something else
	// ... but template parameters if any
	scope.emitTmplParametersIfAny();
	ir::emit::call(irout, callret, functor);
	return true;
}


bool emitFuncCallWithParameters(Scope& scope, uint32_t functor, uint32_t& localvar, AST::Node& node) {
	auto& irout = scope.ircode();
	auto callret = ir::emit::alloc(irout, scope.nextvar());
	localvar = callret; // the new expression value
	ir::emit::ScopeLocker opscope{irout};
	bool success = scope.visitASTExprCallParameters(node);
	scope.emitTmplParametersIfAny();
	scope.emitDebugpos(node);
	ir::emit::call(irout, callret, functor);
	return success;
}


bool emitShortCircuitFuncCall(Scope& scope, uint32_t functor, uint32_t& localvar, AST::Node& node) {
	auto& irout = scope.ircode();
	uint32_t ret__bool = ir::emit::alloc(irout, scope.nextvar());
	// using another intermediate value to mutate it into a real object
	// if necessary
	uint32_t callret = ir::emit::alloc(irout, scope.nextvar());
	localvar = callret; // the new expression value
	// since a shortcircuit label is provided, 2 scopes (because 2 parameters)
	// must be generated by `visitASTExprCallParameters`
	// for post labelid update
	Scope::ShortcircuitUpdate scupdt;
	bool success = scope.visitASTExprCallParameters(node, &scupdt);
	if (unlikely(!!scope.lastPushedTmplParams)) {
		scope.lastPushedTmplParams = nullptr;
		ice(node) << "unsupported generic type parameters for shortcircuit functions";
		success = false;
	}
	scope.emitDebugpos(node);
	ir::emit::call(irout, ret__bool, functor);
	// end of scope for 2nd parameter
	// this way, a jump just after the first one will not try to release the second one
	ir::emit::scopeEnd(irout);
	// Shortcircuit label
	uint32_t sclabel = ir::emit::label(irout, scope.nextvar());
	// instanciate a temporary variable, if needed for reading a variable
	// member (from the class 'bool' for example)
	// (thus the lvid for this will be exactly (shortcircuitlabel + 1))
	scope.nextvar(); // sclabel + 1
	if (scupdt.offsetPragma != 0)
		irout.at<ir::isa::Op::pragma>(scupdt.offsetPragma).value.shortcircuitMetadata.label = sclabel;
	if (scupdt.offsetStackalloc != 0)
		irout.at<ir::isa::Op::stackalloc>(scupdt.offsetStackalloc).lvid = sclabel + 1;
	ir::emit::scopeEnd(irout);
	ir::emit::alloc(irout, scope.nextvar(), nyt_u64); // allocating for sizeof
	ir::emit::pragma::shortcircuitMutateToBool(irout, callret, ret__bool);
	return success;
}


} // namespace


bool Scope::visitASTExprCallParameters(AST::Node& node, ShortcircuitUpdate* shortcircuit) {
	assert(node.rule == AST::rgCall);
	// parameter index
	uint paramCount = 0;
	// at least one named-parameter has been encountered ?
	bool namedParameterFound = false;
	// information related to all pushed parameters
	struct {
		uint32_t localvar = 0;
		AnyString name; // acquired named
	}
	pushedIndexedParam[config::maxPushedParameters];
	auto& irout = ircode();
	for (auto& child : node.children) {
		switch (child.rule) {
			case AST::rgCallParameter:
			case AST::rgCallNamedParameter: {
				if (unlikely(paramCount >= config::maxPushedParameters)) {
					error(child) << "too many pushed parameters";
					return false;
				}
				// is the parameter named ?
				bool isNamed = (child.rule == AST::rgCallNamedParameter);
				// detect mixed-up named and indexed parameters
				if (not isNamed) {
					if (unlikely(namedParameterFound))
						return (error(node) << "got mixed indexed and named parameters");
				}
				else
					namedParameterFound = true;
				// get the temporary parameter info
				auto& paraminfo = pushedIndexedParam[paramCount];
				AnyString name; // parameter name
				for (auto& paramchild : child.children) {
					switch (paramchild.rule) {
						case AST::rgExpr: {
							// ** short circuit evaluation ** The second parameter may be evaluated
							// only if the first one does not suffice to determine the value of
							// the expression
							//
							// Nothing can be decided yet (needs typing) so a few 'nop' will be
							// added to avoid invalid pointers (to no longer matching instructions) and to
							// reduce costly memory operations for inserting instructions
							if (shortcircuit != nullptr) {
								if (paramCount == 1) { // insert 'nop' _BEFORE_ the second parameter
									// remember the current offset for inserting code later if needed
									// (+1 to put the offset after 'stackalloc')
									irout.reserve(irout.opcodeCount() + 4);
									// this temporary variable is exactly 'label id + 1' and already reserved
									// (see visitASTExprCall) and can be used for reading a variable member
									shortcircuit->offsetStackalloc = irout.opcodeCount();
									ir::emit::alloc(irout, 0 /*label + 1*/);
									ir::emit::nop(irout); // fieldget, if not builtin type
									ir::emit::nop(irout); // jump
								}
								// generate scope to prevent against unwanted var release in case of jump
								// (will be released later in `Scope::visitASTExprCall`)
								ir::emit::scopeBegin(irout);
							}
							// visit the parameter
							bool visited = visitASTExpr(paramchild, paraminfo.localvar);
							if (unlikely(not visited))
								return false;
							if (unlikely(isNamed and name.empty()))
								return (ice(paramchild) << "got an empty name for a named parameter");
							break;
						}
						case AST::rgIdentifier: {
							if (likely(isNamed)) {
								name = paramchild.text;
								paraminfo.name = acquireString(name);
								assert(shortcircuit == nullptr and "named param not accepted with shortcircuit");
								break;
							}
							// no break here - to go to unexecped node
						}
						default:
							return unexpectedNode(paramchild, "[ir/expr/call-parameter]");
					}
				}
				++paramCount;
				break;
			}
			//case AST::rgCallNamedParameter:
			default:
				return unexpectedNode(child, "[ir/expr/call]");
		}
	} // each child
	if (shortcircuit) {
		shortcircuit->offsetPragma = irout.opcodeCount();
		ir::emit::pragma::shortcircuitMetadata(irout, 0 /*label*/);
		if (unlikely(paramCount != 2))
			ice(node) << "invalid number of parameters for shortcircuit";
	}
	// push all parameters, indexed and named
	for (uint32_t i = 0; i != paramCount; ++i) {
		const auto& info = pushedIndexedParam[i];
		ir::emit::push(irout, info.localvar, info.name);
	}
	return true;
}


bool Scope::visitASTExprCall(AST::Node* node, uint32_t& localvar, AST::Node* parent) {
	assert(!node or node->rule == AST::rgCall);
	emitDebugpos(node ? node : parent);
	auto& irout = ircode();
	// ask to resolve the call to operator ()
	auto func = ir::emit::alloc(irout, nextvar());
	ir::emit::identify(irout, func, "^()", localvar);
	bool hasParameters = node and not node->children.empty();
	if (not hasParameters)
		return emitFunCallNoParameter(*this, func, localvar);
	// short-circuit only applies to func call with 2 parameters
	// but the code for minimal evaluation can not be determined yet (some
	// member may have to be read, or maybe it should not be done at all)
	// this flag will only prepare some room for additional opcodes if required
	return not isShortcircuit(*node, parent)
		? emitFuncCallWithParameters(*this, func, localvar, *node)
		: emitShortCircuitFuncCall(*this, func, localvar, *node);
}


} // namespace Producer
} // namespace ir
} // namespace ny
